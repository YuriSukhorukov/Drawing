using System;using System.Collections.Generic;using System.Linq;public interface ICreator<T>{	T Create ();}public interface IObjectPool<T>{	T Create();	T Next();	T Prev();		void Free(T item);}public abstract class CreatorStrategy<T>: ICreator<T>{	public virtual T Create()	{		throw new NotImplementedException();	}	public abstract void Reset();}public abstract class ObjectPool<T>: IObjectPool<T>, IDisposable{	public int Count { get; private set; }	public int DefaultCount { get; private set; }	public List<T> Objects;	protected abstract CreatorStrategy<T> CreatorStrategy { get; }	public ObjectPool(int count)	{		Objects = new List<T>();		Count = count;		DefaultCount = count;	}	public T Create()	{		return CreatorStrategy.Create();	}	public T Next()	{		T next = Objects.Count < Count ? Create() : RemoveFirst();		Objects.Add(next);		return next;	}	public T Prev()	{		T prev = RemoveLast();		Objects.Insert(0, prev);		return prev;	}	public T NewFirst()	{		if (Objects.Count == Count)			Count += 1;		T next = Create();		Objects.Add(next);		return next;			}	public T NewLast()	{		if (Objects.Count == Count)			Count += 1;		T prev = Create();		Objects.Insert(0, prev);		return prev;	}	public T NewTo(int index)	{		if (Objects.Count == Count)			Count += 1;		T newTo = Create();		Objects.Insert(index, newTo);		return newTo;	}	public virtual void Free(T item)	{		Objects.Remove(item);	}	public virtual void Dispose()	{		Count = DefaultCount;		Objects.Clear();		CreatorStrategy.Reset();	}	private T RemoveLast()	{			T last = Objects.Last();		Objects.Remove(last);		return last;	}	private T RemoveFirst()	{		T first = Objects.First();		Objects.Remove(first);		return first;	}}